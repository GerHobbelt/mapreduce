Note:  The algorithm treats all edges as undirected edges.

Nv = number of vertices in entire graph
Ne = number of edges in entire graph
Nz = number of zones = current number of connected components
Vi = vertex = unique ID = 1 int
Eij = edge = two vertex IDs = 2 ints
Zi = root vertex for a zone = zone ID = 1 int
Di = distance from vertex in a zone to root = 1 double
Si = vertex state = (Zi,Di) = 2 ints

Pre-processing:

Map 1
  input: read list of Ne edges
  output: emit 2 KV per edge
  Key = Vi, Val = Eij
  Key = Vj, Val = Eij
Collate 1
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = Eij, Eik, Eim, ... (all edges of Vi)
Reduce 1
  input: one KMV pair per vertex Vi
  output: emit KV for each edge in MV, where initial Si = (Vi,0)
  Key = Eij or Eji, Val = Si

Loop:

Collate 2
  input: 2*Ne KV pairs
  output: Ne KMV pairs
  Key = Eij, MVal = Si, Sj (2 states of vertices in edge)
Reduce 2
  input: one KMV pair per edge
  output: emit several KV pairs based on Si,Sj values of vertices in edge
  Dmin = min(Di,Dj), Dmax = max(Di,Dj), Zmax = max(Zi,Zj)
  if Zi = Zj: emit 2 KV pairs
    Key = Zi, Val = Dmin, Eij, Si, Sj
    Key = Zi, Val = -B, Eij, Si, Sj where B = Dmax + (Dmax-Dmin)/(Dmax+1)
  if Zi != Zj: emit 3 KV pairs
    Key = Zi, Val = Dmin, Eij, Si, Sj
    Key = Zj, Val = Dmin, Eij, Si, Sj
    Key = Zmax, Val = -Alpha, Eij, Si, Sj where Alpha = big number

Collate 3
  input: several KV pairs per edge
  output: Nz KMV pairs
  Key = Zi, MVal = (D, Eij, Si, Sj), (D, Eij, Si, Sj), ...
    (multiple entries for all edges of all vertices in zone)
Reduce 3
  input: one KMV pair per zone
  output: emit two KV pairs for each edge in MV
  set flag = 0 for each proc
  create empty hash table for this KMV
  put all Si values in MV into hash table, keyed by Vi
  note: all Si of same Vi should be identical at this point
  sort edge entries in MV in ascending order by D so can loop over them
  loop over edges in MV in sorted order:
    extract Si and Sj for Eij from hash table
    Zmin = min(Zi,Zj), Dmin = lowest D of vertex whose S has Zmin
    if Si or Sj is already (Zmin,Dmin), don't change it
    if Si or Sj is not (Zmin,Dmin), change it to Snew = (Zmin,Dmin+1)
      and put it back in hash table
    set flag = 1 if any Si was changed
    if only want distances in a single input component, can test if Ds changed
  build another hash table to store unique Eij in MV
  emit 2 KV per unique edge in MV:
    Key = Vi, Val = Eij Si
    Key = Vj, Val = Eij Sj
    Si, Sj are extracted from hash table
  delete 2 hash tables for the KMV
  if flag on all procs still = 0, exit loop

Collate 4
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = (Eij,Si), (Eik,Si), (Eim,Si), ... (all edges of Vi)
Reduce 4
  input: one KMV pair per vertex
  output: emit one KV pair for each edge in MV
  compute best Si from all values in MV, best = min seed, then min distance
  for each Eij in MV, emit 1 KV pair
    Key = Eij, Val = best Si

End of Loop (return to Collate 2)

Done:
  each zone is now a connected component
  Si for each vertex identifies zone Zi it is in, and its distance from Zi


