Single-source shortest paths via MapReduce
Input:   A directed graph
Output:  For each vertex Vi, the shortest weighted distance from a randomly
         selected source vertex S to Vi, along with the predecessor vertex 
         of Vi in the shortest weighted path from S to Vi.

Assume:  Vertices are identified by positive whole numbers in range [1:N].
         Distances are passed through the MapReduce objects as negative
         numbers (so we can distinguish them from vertices or weights).
         Assume edge weights are positive whole numbers.

1.  Create new MapReduce objects, Edges and Vertices
Map:     Input graph from files as in link2graph_weighted.
         Output:  Edges:  Key-values representing edges Vi->Vj with weight Wij
                          Key = Vi    
                          Value = {Vj, Wij} 
                  Vertices:  Key-values representing vertex Vi
                             Key = Vi with hashkey ID
                             Value = Vi in [1:N]

2.  Create a new MapReduce object, Paths.
Select a source vertex.  
      Processor 0 selects a random number S in range [1:N] for N vertices.
      Processor 0 emits into Paths key-value pair [S, {-1, 0, false}], 
      signifying that vertex S has distance zero from itself, with no
      predecessor.  The "false" value will prevent the BFS loop from 
      ending early.

3.  Perform a BFS from S, editing distances as visit vertices.
done = 0;
while (!done) {
  done = 1;
  Add Edges to Paths.
  Collate Paths by vertex; collects edges and any distances computed so far.

  Reduce:  Input:   Key-multivalue 
                    Key = Vi
                    Multivalue = [{Vj, Wij} for all adj vertices Vj] + 
                                  (possibly) {Vk, Dk, true/false} representing
                                  shortest distance from S to Vi through
                                  preceding vertex Vk.  Distances with "true"
                                  value are the previously accepted best
                                  distance from S to Vi.
                   
           Compute: If any distances from S to Vi have been computed so far, 
                    find minimum distance D; keep track of the preceding
                    vertex Vd giving this best distance.  
                    If changed the minimum distance, done = 0.

           Output:  Only if a minimum distance was computed, emit one key-value
                    for each adjacent vertex Vj:
                    Key = Vj
                    Value = {Vi, D+Wij, false}
                    Also emit best distance so far for Vi:
                    Key = Vi
                    Value = {Vd, D, true}, where Vd is the preceding vertex
                            corresponding to the best distance.

  MPI_Allreduce(done, MPI_MIN);
}

4.  Finish up:    Paths may have more than one distance per vertex.  Take the 
                  best.  Also, want to include vertices that weren't along a
                  path from S (i.e., aren't connected to S).

  Create MapReduce object Init with initial condition of infinity for distance
                  from S.  Copy Vertices to Init.  Clone Init.
  Reduce(Init):   Input:   Key-multivalue
                           Key = Vi with hashkey ID
                           Multivalue = Vi in [1:N]
                  Output:  Key = Vi in [1:N]
                           Value = {-1, INT_MAX, false}

  Add Init to Paths.
  Collate Paths
  Reduce(Paths):  Input:   Key-multivalue
                           Key = Vi
                           Multivalue = [{Vk, Dk, true/false}] representing the 
                                        shortest
                                        distance from S to Vi through preceding
                                        vertex Vk.

                  Compute: Find minimum distance D, keeping track of the 
                           corresponding preceding vertex Vd.

                  Output:  Emit distance from S to Vi:
                           Key = Vi
                           Value = {Vd, D}

5.  Output results.

