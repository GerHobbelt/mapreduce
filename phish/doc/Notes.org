eneral PHISH documentation

* Intro

2 parts: Python script (bait.py) and library (libphish.a)
each stand-alone app calls library
difference between normal datum and "done" datum

* bait.py command-line syntax:

bait.py -switch values ...

  -np N = processor count
    also -n or -p
    default = 1
  -var ID str1 str2 ... = assign strings to a variable ID
    also -v
    default = no variables defined
  -hostfile filename = list of processors to run on
    also -h
    default = ""
  -configfile filename = MPI config file to create
    also -c
    default = "configfile"
  -mpi style
    also -m
    style = "mpich" or "openmpi"
    default = "mpich"

* Input script parsing by bait.py:

parsing rules:
  blank lines OK
  comment char = #, delete all trailing
  continuation char = &, with nothing following (including spaces)
variable substutution:
  what are rules for this, LAMMPS like ???

* Input script commands for bait.py:

** set keyword value

  keyword = verbosity or makefile
    verbosity = 0 or 1 (default = 0) = currently not used
    makefile = filename (default = Makefile) = currently not used
      should be used to build EXE files

** variable ID str1 str2 ...

  assign multiple strings to a variable ID

** sp ID style args

  define a stream process with ID
  style = name of associated stand-alone executable
  args = args that will be passed to executable when launched

** connect ID1 style ID2 

  connect output of sp ID1 to input of sp ID2
  style = kind of connection
  style = one2many one2many/rr many2many many2one one2one
    one2many = one output sent to many inputs via hashing
    one2many/rr = one output sent to many inputs in roundrobin fashion
    many2many = many outputs sent to many inputs via hashing
    many2one = many outputs sent to one input
    one2one = one output to one input

** layout ID nprocesses

  # of processes to launch for each sp

* Library functions:

** void phish_init(char *name, int nrecvmax, int nsendmax, int *nargptr, char ***argsptr)

name = name of application
nrecvmax = max # of recv styles
nsendmax = max # of send styles
nargptr = ptr to nargs
argsptr = ptr to args

calls MPI_Init()

looks for args of this form and strips them off:

-recv nrecv style args style args ...
  nrecv sets of style/args
  style = one2one or one2many or one2manyrr or many2one or many2many
  args = recvfirst recvprocs
-send nsend
  nsend sets of style/args
  style = one2one or one2many or one2manyrr or many2one or many2many
  args = sendfirst sendprocs
-args arg1 arg2 ... = the original args for the app

NOTE: for now don't allow nsend or nrecv > 1, no logic to support this

** void phish_close()

calls MPI_Finalize()

** void phish_error(char *str)

prints error string and MPI_Abort()

** double phish_timer()

just returns MPI_Wtime()

** void phish_callback(int flag, void (*callback)(char *, int))

sets a callback function
flag = DATUM or PROBE or DONE

** void phish_loop()

continuous loop, waiting for MPI_Recv()
if a DONE message, continue until recv recvprocs of them,
  then invoke done callback, and return
else invoke data callback with nbyte message

** void phish_probe()

same as phish_loop(), except that does a MPI_Iprobe() for 
  message instead of a blocking MPI_Recv()
if no message is available, and if a PROBE callback is defined,
  then it returns to caller, so it can do more work
for example, the caller, can query its child process for incoming "messages"
  to process

** void phish_send(char *buf, int nbytes)

send buf of nbytes to one or more other procs

one2one and many2one = send to sendfirst
one2many/rr = send to sendfirst
  NOTE: shouldn't this do the round robin ?
one2many and many2many = error (need to use phish_send_key())

** void phish_send_key(char *buf, int nbytes, char *key, int keybytes)

send buf of nbytes to one or more other proc, based on key

one2one and many2one = send to sendfirst
one2many and many2many = hash the key, divide hash result across sendprocs,
  send to specific proc
one2many/rr = send to sendfirst + sendoffset, then increment sendoffset

** void phish_send_done()

send DONE message to each receiver I send to

one2one and many2one = send just to sendfirst
one2many and one2many/rr and many2many = send to all sendprocs
  starting at sendfirst

* Apps:

each app has main and its own functions

main:
  phish_init()
  phish_callback() as needed
  process app args
  phish_loop()
  phish_close()

** count

count instances of keyed datums

syntax: no args

creates an internal hash, so it can count instances of keys
hash key = string, hash value = count
keeps track of largest key it receives

datum method:
  treat buf of nbytes as a string and hash it
  increment hash value for that string

done method:
  iterate over hash table
  send all its entries downstream as "count string"
  send DONE message to notify receivers

** file2words

read file and emit words

syntax: no args

datum method:
  treat message as filename
  open it, parse into words separated by whitespace
  send each word, both as message and as a key

done method:
  send DONE message to notify receivers

** filegen

emit filenames

syntax: filengen file1 file2 ...

send file names one by one to receivers
then send DONE message to notify receivers

no datum method
no done method

** ping

reflect messages to a receiver

syntax: ping N M
N = # of times to ping/pong with partner proc
M = # of bytes in a message

fill M-byte buffer with NULLs
send it and go into loop

datum method:
  when recv from partner
  increment count and send back to partner
  when count hits M, send DONE message to notify receivers

no done method

** pong

reflect messages to a sender

syntax: no args

datum method:
  when recv from partner, send message back to partner

done method:
  send DONE message to notify receivers

** print

print datums to screen or file

syntax: print -f filename
-f is optional, if not specified, prints to stdout

datum method:
  print string

done method:
  close file

** slowdown

read datum and emit it with slowdown delay

syntax: slowdown delta
delta = time to delay (in seconds)

read each datum and insure delay seconds have passed
before writing it downstream

datum method:
  query time since last datum was processed and invoke usleep() if needed
  send datum downstream

done method:
  send DONE message to notify receivers

** sort

sort datums, emit highest count ones

syntax: sort N
N = keep top N of sorted list

datum method:
  assume message is "int string"
  store (int,string) as pair in a vector list

done method:
  sort the list based on integer count
  send the top N list items downstream as "count string"
  send DONE message to notify receivers

** wrapsink

wrap a child process which consumes datums by reading from stdin

syntax: wrapsink "program"
"program" can be any string with flags, redirection, etc
enclose in quotes to prevent shell from processing it

write datums to child, one by one, as lines of input
write done via popen pipe

datum method:
  write datum to pipe with appended newline

done method:
  close the pipe

** wrapsource

wrap a child process which creates datums by writing to stdout

syntax: wrapsource -f "program"
-f is optional

if -f is specified, receive filenames in stream and
  invoke child process on each filename
  generate "program" via sprintf() using filename as arg
  so "program" presumable has %s in it
if -f is not specified, invoke child process just once using "program"

"program" can be any string with flags, redirection, etc
enclose in quotes to prevent shell from processing it

read lines of output from child one by one as datums via a pipe
send them downstream via phish_send()

datum method:
  launch the child process on the filename
  read all its output until child exits
  send each line of output downstream vis phish_send w/out newline

done method:
  send DONE message to notify receivers
  
** wrapss

wrap a child process which consumes and creates datums via stdin/stdout

syntax: wrapss "program"
"program" can be any string with flags, redirection, etc
enclose in quotes to prevent shell from processing it

open 2 pipes to child via pipe()
fork() into parent and child processes
parent calls phish_probe() to query incoming messages and child output
child hooks its stdin/stdout to 2 pipes via dup2()
child invokes the "program" via execv()

datum method:
  write datum to pipe with appended newline

probe method:
  poll pipe for output from child
  if output is there, read it and break into lines
  phish_send() each line downstream as string w/out newline

close method:
  close write pipe to child so it will know parent is done
  wait for all output from child read pipe
  send DONE message to notify receivers

* Standalone Apps that can be wrapped as child proceses

** echo

echo lines from stdin to stdout

** reverse

reverse characters in lines from stdin and write to stdout

* Scripts:

** in.pp = ping-pong test between 2 processes

2 procs, each connect to each other via one2one
send message of M bytes back-and-forth N times

** in.test = test bait.py syntax processing

arbitrary commands to test that bait.py can process it correctly

** in.wc = word count from files

open files from list
convert to words
count word occurrence
sort to keep top N
print the results

can use many procs for file reading and accumulating counts
like MapReduce

** in.wrapsink = reverse each filename in a list of filenames

uses wrapssink
pass filenames to simple standalone reverse program
can launch multiple instances of reverse

** in.wrapss = reverse each filename in a list of filenames

uses wrapss
wrap simple standalone reverse program
can launch multiple instances of reverse
