Luby's alg for maximal indenpendent sets in MapReduce
SJP, 30 Apr 09
original version for Python file

notation:
  Vi = ID of vertex I
  Eij = I,J edge = Vi Vj
  Ri = random value (float) assigned to Vi
  F = flag assigned to a vertex = W (winner) or L (loser) or U (unknown)

initialize:
  store graph with edges as keys
  eliminate Vi = Vj edges
  eliminate double-counted edges where both Eij and Eji exist
  assign Ri to each vertex
  key = Eij, value = Ri Rj where Vi < Vj
  clone()

while any edges remain:
  reduce1()
    operate on each edge Eij
    if any of multivalues is L by itself, skip this edge altogether
    input key = Eij, value = Ri Rj where Vi < Vj
    play the Luby game:
      assign W to vertex with largest R
      assign L to vertex with smallest R
      break ties with vertex ID
    emit 2 KV pairs:
      key Vw, value = W Rw Vl Rl
      key Vl, value = L Rl Vw Rw
  collate()
  reduce2()
    operate on each vertex I
    input key = Vi, one value per edge = F Ri Vj Rj
    if all F = W:
      emit self as 1 KV pair:
        key = Vi, value = W
      emit 1 KV pair per edge:
        key = Vj, value = L Rj Vi Ri
    else:
      emit 1 KV pair per edge:
        key = Vj, value = U Rj Vi Ri
  collate()
  reduce3()
    operate on each vertex J
    input key = Vi, one value per edge = F Ri Vj Rj plus extra for W
    if any F = W by itself:
      add Vi to independent set
      eliminate this vertex and its edges from graph by just returning
      edges into this vertex will be marked L (see next section)
    if any F = L:
      eliminate this vertex and its edges from graph (on next iter) by L emit
      emit 1 KV pair per edge:
        key = Eij, value = L where Vi < Vj
    else:      
      emit 1 KV pair per edge:
        key = Eij, value = Ri Rj where Vi < Vj
  collate()

----------------
modified version for C++ and paper

notation:
  Vi = IDi Ri = ID of vertex I, random value assigned to each vertex
  Ri can be dropped if Vi is randomized (see below)
  Eij = I,J edge = Vi Vj = IDi Ri IDj Rj
  flag assigned to a vertex = W (winner) or L (loser)

initialize:
  empty MR for accumulating maximal independent (MI) set vertices
  store graph with edges as keys (Eij,NULL)
  eliminate Vi = Vj edges
  eliminate double-counted edges where both Eij and Eji exist
  assign random values to each vertex:
    a) store vertex as IDi Ri where Ri is a random #
    b) randomly shuffle the 1-N IDs to have new IDs, then map back at end
       map: emit (Ri,Vi) where Ri = random @, Vi = 1 to N
       aggregate()
       map: emit (Vi,Vi*) where Vi = old Vi, Vi* = new 1-N
       use this to re-label the Eij keys
  clone() to create initial KMV

while any edges remain:
  reduce1()
    operate on edges, all with I < J
    delete losing edges, flag vertices as W/L via Luby's game
    input KMV: Eij: NULL NULL (one or both of NULL may be L)
    each edge can have 2 values (or just 1 on initial iteration)
    if any value is L, skip this edge (deletes it)
    play the Luby game:
      assign W to smallest vertex (break ties in RN with vertex IDs)
      assign L to largest vertex
    emit 2 KV pairs: (Vw, Vl W), (Vl, Vw L)
  collate()
  reduce2()
    operate on vertices
    pick winning vertices
    input KMV, Vi: E E E E ... (one value per edge)
    if all E are winners:
      emit (Vi,NULL) to MR that is accumulating MI set vertices
      emit 1 KV per edge: (Vj, Vi L)
    else:
      emit 1 KV per edge: (Vj,Vi)
  collate()
  reduce3()
    operate on vertices
    pick losing vertices, delete all their edges
    input KMV, Vi: E E E E ... (one value per edge)
    if any E are losers:
      emit 1 KV per edge: (Eij,L) with Vi < Vj
    else:      
      emit 1 KV per edge: (Eij,NULL) with Vi < Vj
  collate()

complete the MR with MI set vertices
