Single-source shortest paths via MapReduce
Input:   A directed graph
Output:  For each vertex Vi, the shortest weighted distance from a randomly
         selected source vertex S to Vi, along with the predecessor vertex 
         of Vi in the shortest weighted path from S to Vi.

Assume:  Vertices are identified by positive whole numbers in range [1:N].
         Distances are passed through the MapReduce objects as negative
         numbers (so we can distinguish them from vertices or weights).
         Assume edge weights are positive whole numbers.

1.  Create a new MapReduce object, Edges.
Map(Edges):  Input graph from files as in link2graph_weighted.
             Output:  Key-values representing edges Vi->Vj with weight Wij
                      Key = Vi    
                      Value = {Vj, Wij} 

2.  Create a new MapReduce object, Paths.
Select a source vertex.  
      Processor 0 selects a random number S in range [1:N] for N vertices.
      Processor 0 emits into Paths key-value pair [S, {0, -1}], 
      signifying that vertex S has distance zero from itself, with no
      predecessor.

3.  Perform a BFS from S, editing distances as visit vertices.
done = 0;
while (!done) {
  done = 1;
  Add Edges to Paths.
  Collate Paths by vertex; collects edges and any distances computed so far.

  Reduce:  Input:   Key-multivalue 
                    Key = Vi
                    Multivalue = [{Vj, Wij} for all adj vertices Vj] + 
                                  (possibly) {Vk, -Dk} representing
                                  shortest distance from S to Vi through
                                  preceding vertex Vk.
                   
           Compute: If any distances from S to Vi have been computed so far, 
                    find minimum distance D; keep track of the preceding
                    vertex Vd giving this best distance.  
                    If changed the minimum distance, done = 0.

           Output:  Only if a minimum distance was computed, emit one key-value
                    for each adjacent vertex Vj:
                    Key = Vj
                    Value = {Vi, -(D+Wij)}
                    Also emit best distance so far for Vi:
                    Key = Vi
                    Value = {Vd, -D}, where Vd is the preceding vertex
                            corresponding to the best distance.

  MPI_Allreduce(done, MPI_MIN);
}

4.  Finish up:  Paths may have more than one distance per vertex.  Take the 
                best.

  Collate Paths
  Reduce:  Input:   Key-multivalue
                    Key = Vi
                    Multivalue = [{Vk, -Dk}] representing the shortest
                                 distance from S to Vi through preceding
                                 vertex Vk.

           Compute: Find minimum distance D, keeping track of the corresponding
                    preceding vertex Vd.

           Output:  Emit distance from S to Vi:
                    Key = Vi
                    Value = {Vd, D}
