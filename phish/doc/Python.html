<HTML>
<CENTER><A HREF = "Examples.html">Previous Section</A> - <A HREF = "http://phish.sandia.gov">PHISH WWW Site</A> -
<A HREF = "Manual.html">LAMMPS Documentation</A> - <A HREF = "Manual.html">Next Section</A> 
</CENTER>




<HR>

<H3>6. Python interface to the PHISH library 
</H3>
<P>How to wrap the PHISH lib with Python.
</P>
<P>This allows minnows to be written in Python and make calls
to the PHISH library.
</P>
<P>Include setup of Python info from MR-MPI.
</P>
<P>def init(arguments=sys.argv):
  """Initializes phish and returns a context object for communicating with the
  rest of the school.  Takes the process argv (which may be modified) as its
  sole argument."""
</P>
<P>class context:
  """Abstract interface for a Phish context, which is used for communication by
  individual minnows."""
</P>
<P>  def name(self):
    """Returns the human-readable name for this minnow."""
</P>
<P>  def input_ports(self):
    """Returns a list of connected input ports.  Note that this list is kept
    up-to-date as input ports are closed."""
</P>
<P>  def output_ports(self):
    """Returns a list of connected output ports.  Note that this list is
    kept up-to-date as output ports are closed."""
</P>
<P>  def enable_input_port(self, port, message_callback, closed_callback=None, optional=False):
    """Specifies an input port to be enabled, along with a callback to be
    called when a message is received on the port, an optional callback to be
    called when the port is closed (i.e. all connections to the port are
    closed), and a flag specifying whether the port is optional (i.e. whether
    it is an error condition if there are no connections to this port)."""
</P>
<P>  def enable_output_port(self, port):
    """Specifies an output port to be enabled.  It is an error to attempt
    sending a message on a port that hasn't been enabled, or to make a
    connection to such a port."""
</P>
<P>  def set_last_port_closed_callback(self, callback):
    """Specifies a callback to be called exactly once when every input port has
    been closed.  Note: this callback will never be called for minnows that
    have no input ports."""
</P>
<P>  def loop(self):
    """Called to begin an event loop that will receive messages and invoke
    registered callbacks.  Loops cannot be nested, so subsequent calls to
    loop() before calling loop_complete() will be ignored."""
</P>
<P>  def loop_complete(self):
    """Called to exit an event loop started with loop().  Note that multiple
    calls to loop_complete() and calls to loop_complete() before calling loop()
    will be ignored."""
</P>
<P>  def send(self, message, output_port=0):
    """Sends a message to a single minnow connected to the given output
    port, choosing recipients in round-robin order."""
</P>
<P>  def send_all(self, message, output_port=0):
    """Sends a message to every minnow connected to the given output
    port."""
</P>
<P>  def send_hashed(self, key, value, output_port=0):
    """Sends a key-value pair to a single minnow connected to the given
    output port, choosing recipients based on a hash of the key."""
</P>
<P>  def close_port(self, output_port):
    """Notifies downstream minnows that the given output port has been closed."""
</P>
<P>  def close(self):
    """Closes the context and releases any resources allocated by the library.
    Note that this also implicitly closes any open output ports and completes
    any running loop."""
</P>
<P>def school(backend="zmq"):
  """Factory function for creating school objects.  The backend argument is
  used to specify the backend to use for communications.  Currently, only "zmq"
  is supported as a backend."""
</P>
<P>class school:
  """Abstract interface for managing a collection of minnow processes."""
</P>
<P>  def create_minnows(self, name, arguments, count=1, hosts=None):
    """Starts one-or-more minnow processes, using the given command-line
    arguments, count of processes to create, and optional list of hosts where
    processes should be run, returning a list containing handles to the new
    minnows.  The hosts parameter must either be a single host, in which case
    all the new minnow processes will be run on that host (useful to put I/O
    minnows close to disk hardware, for example); or, the hosts parameter must
    be a list of host names, one-per-minnow."""
</P>
<P>  def all_to_all(self, output_minnows, output_port, input_port, input_minnows):
    """Creates all-to-all connections from the output ports on one set of
    minnows to the input ports of another."""
</P>
<P>  def one_to_one(self, output_minnows, output_port, input_port, input_minnows):
    """Connects an output port from one minnow to the input port of the
    corresponding minnow, for two equal sets of minnows."""
</P>
<P>  def start(self):
    """Notifies the school that all minnows have been created / connected, and
    processing may begin."""
</P>
</HTML>
