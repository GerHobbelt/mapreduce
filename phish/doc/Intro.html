<HTML>
<CENTER><A HREF = "Manual.html">Previous Section</A> - <A HREF = "http://phish.sandia.gov">PHISH WWW Site</A> -
<A HREF = "Manual.html">LAMMPS Documentation</A> - <A HREF = "Bait.html">Next Section</A> 
</CENTER>




<HR>

<H3>1. Introduction 
</H3>
<P>give a quick index to this page
</P>
<P>what is streaming data
  continuous
  high bandwidth
  cannot afford to see it more than once
</P>
<P>goals: informatics data in broadest sense, stats, data mininng,
  anomaly detection
</P>
<P>powerful paradigm: stateful independent processes, that
  are small programs that do one things, run a large collection
  of these that communicate is a designed fashion, to acheive
  parallelism, running
  that ship datums (chunk of bytes) to each other in continuous
  fashion.  Can be infinite stream or processing of large
  archive of data
</P>
<P>what kind of algorithms can be expressed in this mode?
various stream models of computation: e.g. W-stream, X-stream
our own interest is graph algorithms and data mining on 
hi-volume streams of data, but many other data processing
tasks can be formulated in this fashion
</P>
<P>other products: DataMiner from IBM (see Karl list)
</P>
<P>dropping data versus perfrect answer (pipeline throttles itself)
</P>
<P>Simple example: MR word count
</P>
<P>why we wrote PHISH
  different than typicaly MPI where all procs run one program
  wanted to go beyond MPI to sockets, hetergenous machines
    add/delete minnows dynamically
  wanted to automate some of the parallelism inherent in 
    processing big data, a la MapReduce (this is the hashing idea)
  make it as simple as possible to process data in parallel
</P>
<P>all of these goals reflected in name PHISH
</P>
<P>ulterior motive, phish swim in a stream, minnows 
are small, but work in coordinated fashion to some
goal (evade preadtor, find food)
</P>
<P>brings us to PHISH lingo
</P>
<P>minnow: read and compute on and write (altered) datums
school: collection of minnows
bait the hook via bait.py
phish wrapper = Python
</P>
<P>Features of PHISH
</P>
<P>lib = simple (1000 lines), C-interface, portable (list langaunges),
Python (phish) wrapper provided
</P>
<P>The individual programs can be written in any language (e.g. C, C++,
Fortran, Python) and link to the PHISH library so that they can
receive incoming data from upstream sources, bundle their data, and
send it downstream.
</P>
<P>paralllel data procesing via parallel launch or hashing
</P>
<P>lib on top of MPI or sockets - latter via ZMQ lib
(geogrphically diverse machines)
</P>
<P>mechanism to hook multiple PHISH schools togehter via sockets
  means can add/delete processes
</P>
<P>examples for streaming MR, CC finidng in parallel, MR-like jobs
</P>
<P>benchmarks for running on MPI or sockets
</P>
<P>minnows that let you wrap existing stand-alone programs that
read from stdin and write to stdout
</P>
<P>Steps to running a PHISH calculation
</P>
<P>a) write one or more minnows that call the PHISH library
b) write a script listing the minnows and the communication patterns between them
c) ues the Bait.py tool to process the input script
c) run the file (via MPI or a shell script) produced by Bait.py
</P>
<P>PHISH has 2 parts: Python script (bait.py) and library (libphish.a)
</P>
<P>But can also process corpus of files.
</P>
<P>Break stream up into datums = chunk of bytes.
</P>
<P>Minnows read (swim in) stream, process datums,
can store state, consume or write (altered) datums.
</P>
<P>Can wrap existing apps in PHISH (fish-wrapper).
Minnows are provided
</P>
<P>School of minnows and their connectivity specified
in simple input script, processed with bait.py to
turn into launchable parallel job, either via MPI and
mpirun, or via sockets and a shell script.
</P>
<P>easy path to distributed memory parallel for processing
streaming data
</P>
<P>minnow = stand-alone program (app) that (typically)
does one task, designed to work in tandem with other
minnows, either copies of itself, or totally different
</P>
<P>portable open-source lib, lightweight, easy to call
from any language, including Python
</P>
<P>each stand-alone minnow calls library
</P>
<P>difference between normal datum and "done" datum
</P>
<P>explain acronym
  what each word means
</P>
<P>minnow
school
input script
bait.py
</P>
<P>school of minnows swim in a stream, doing something
coordinated.
</P>
<P>A PHISH input script allows specification of the set of programs to
launch as independent procsses, how many copies of each are inovked,
and the topology of how they connect to each other as they send and
receive data.  Thus the input script encodes an algorithm for
processing continuous data from a stream source or archived data from
files.  The supported communication topologies include a "hashed" mode
of messaging where a "key" is hashed to determine what process to send
data to, which is a means of exploiting parallelism in a streaming
context, akin to a MapReduce operation.
</P>
<P>The sending and receiving of datums between processes is handled
within the PHISH library either by calls to the message-passing
interface (MPI) library, or by sockets via the ZMQ library.  A PHISH
tool converts the input script into a configuration file that can be
launched by either MPI or a shell script.  In the former case, a PHISH
program can run on any platform that supports MPI.  In the latter
case, a PHISH program can run on a single desktop machine or across
any network of (geographically distributed) machines that support
socket connections.
</P>
<P>The PHISH package is open-source software that implements the
<A HREF = "wiki">MapReduce operation</A> popularized by Google on top of standard
MPI message passing.
</P>
<P>The library is designed for parallel execution on distributed-memory
platforms, but will also operate on a single processor.  It requires
no additional software to build and run, except linking with an MPI
library if you wish to perform MapReduces in parallel.  Similar to the
original Google design, a user performs a MapReduce by writing a small
program that invokes the library.  The user typically provides two
application-specific functions, a "map()" and a "reduce()", that are
called back from the library when a MapReduce operation is executed.
"Map()" and "reduce()" are serial functions, meaning they are invoked
independently on individual processors on portions of your data when
performing a MapReduce operation in parallel.
</P>
<P>The MR-MPI library is written in C++ and is callable from hi-level
langauges such as C++, C, Fortran.  A Python wrapper is also included,
so MapReduce programs can be written in Python, including map() and
reduce() user callback methods.  A hi-level scripting interface to the
MR-MPI library, called OINK, is also included which can be used to
develop and chain MapReduce algorithms together in scripts with
commands that simplify data management tasks.
</P>
<P>The goal of the MR-MPI library is to provide a simple and portable
interface for users to create their own MapReduce programs, which can
then be run on any desktop or large parallel machine using MPI.  See
the Background section for features and limitations of this
implementation.
</P>
<P>The distrubution includes a few examples of simple programs that
illustrate the use of MR-MPI.
</P>
<P>Source code for PHISH is freely available for download from the <A HREF = "phish">PHISH
web site</A> and is licensed under the modified <A HREF = "bsd">Berkeley Software
Distribution (BSD) License</A>.  This basically means they can be
used by anyone for any purpose.  See the LICENSE file provided with
the distribution for more details.
</P>
</HTML>
