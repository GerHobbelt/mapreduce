Cohen's algorithm that computes connected components and distance from seed.
Note:  The algorithm treats all edges as undirected edges.

Nv = number of vertices in entire graph
Ne = number of edges in entire graph
Nz = number of zones = current number of connected components
Vi = vertex = unique ID = 1 int
Eij = edge = two vertex IDs = 2 ints
Zi = root vertex for a zone = zone ID = 1 int
Di = distance from vertex in a zone to root = 1 double
Si = vertex state = (Zi,Di) = 2 ints

Pre-processing:

Map 1
  input: read list of Ne edges
  output: emit 2 KV per edge
  Key = Vi, Val = Eij
  Key = Vj, Val = Eij
Collate 1
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = Eij, Eik, Eim, ... (all edges of Vi)
Reduce 1
  input: one KMV pair per vertex Vi
  output: emit KV for each edge in MV, where initial Si = (Vi,0)
  Key = Eij, Val = Si

Loop:

Collate 2
  input: 2*Ne KV pairs
  output: Ne KMV pairs
  Key = Eij, MVal = Si, Sj (2 states of vertices in edge)
Reduce 2
  input: one KMV pair per edge
  output: emit several KV pairs based on Si,Sj values of vertices in edge
  Dmin = min(Di,Dj), Dmax = max(Di,Dj), Zmax = max(Zi,Zj)
  if Zi = Zj: emit 2 KV pairs
    Key = Zi, Val = Dmin, Eij, Si, Sj
    Key = Zi, Val = -B, Eij, Si, Sj where B = Dmax + (Dmax-Dmin)/(Dmax+1)
  if Zi != Zj: emit 3 KV pairs
    Key = Zi, Val = Dmin, Eij, Si, Sj
    Key = Zj, Val = Dmin, Eij, Si, Sj
    Key = Zmax, Val = -Alpha, Eij, Si, Sj where Alpha = big number

Collate 3
  input: several KV pairs per edge
  output: Nz KMV pairs
  Key = Zi, MVal = (D, Eij, Si, Sj), (D, Eij, Si, Sj), ...
    (multiple entries for all edges of all vertices in zone)
Reduce 3
  input: one KMV pair per zone
  output: emit two KV pairs for each edge in MV
  set flag = 0 for each proc
  create empty hash table for this KMV
  put all Si values in MV into hash table, keyed by Vi
  note: all Si of same Vi should be identical at this point
  sort edge entries in MV in ascending order by D so can loop over them
  loop over edges in MV in sorted order:
    extract Si and Sj for Eij from hash table
    Zmin = min(Zi,Zj), Dmin = lowest D of vertex whose S has Zmin
    if Si or Sj is already (Zmin,Dmin), don't change it
    if Si or Sj is not (Zmin,Dmin), change it to Snew = (Zmin,Dmin+1)
      and put it back in hash table
    set flag = 1 if any Si was changed
    if only want distances in a single input component, can test if Ds changed
  build another hash table to store unique Eij in MV
  emit 2 KV per unique edge in MV:
    Key = Vi, Val = Eij Si
    Key = Vj, Val = Eij Sj
    Si, Sj are extracted from hash table
  delete 2 hash tables for the KMV
  if flag on all procs still = 0, exit loop

Collate 4
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = (Eij,Si), (Eik,Si), (Eim,Si), ... (all edges of Vi)
Reduce 4
  input: one KMV pair per vertex
  output: emit one KV pair for each edge in MV
  compute best Si from all values in MV, best = min seed, then min distance
  for each Eij in MV, emit 1 KV pair
    Key = Eij, Val = best Si

End of Loop (return to Collate 2)

Done:
  each zone is now a connected component
  Si for each vertex identifies zone Zi it is in, and its distance from Zi

-------------------------------------------------------------------------
-------------------------------------------------------------------------
Version of Cohen algorithm that does only CC, not distances

Nv = number of vertices in entire graph
Ne = number of edges in entire graph
Nz = number of zones = current number of connected components
Vi = vertex = unique ID = 1 int
Eij = edge = two vertex IDs = 2 ints
Zi = root vertex of Vi = zone ID = 1 int

Pre-processing:

Map 1
  input: read list of Ne edges
  output: emit 2 KV per edge
  Key = Vi, Val = Eij
  Key = Vj, Val = Eij
Collate 1
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = Eij, Eik, Eim, ... (all edges of Vi)
Reduce 1
  input: one KMV pair per vertex Vi
  output: emit KV for each edge in MV, with initial zone Zi = Vi
  Key = Eij, Val = Zi

Loop:

Collate 2
  input: 2*Ne KV pairs
  output: Ne KMV pairs
  Key = Eij, MVal = Zi, Zj
Reduce 2
  input: one KMV pair per edge
  output: emit 1 or 2 KV pairs based on Zi,Zj values of vertices in edge
  if Zi = Zj: emit 1 KV pair
    Key = Zi, Val = Eij, Zi
  if Zi != Zj: emit 2 KV pairs (Zi = winner, Zj = loser)
    Key = Zi, Val = Eij, Zi
    Key = Zj, Val = Eij, Zi

Collate 3
  input: one or two KV pairs per edge
  output: Nz KMV pairs
  Key = Zi, MVal = (Eij, Z), (Eij, Z), ... (all edges of all vertices in zone)
Reduce 3
  input: one KMV pair per zone
  output: emit two KV pairs for each edge in MV
  set flag = 0 for each proc
  loop over edges in MV:
    find winning edge Z* out of all Z values (min Z value)
  loop over edges in MV:
    emit 2 KV per edge in MV:
      Key = Vi, Val = Eij Z*
      Key = Vj, Val = Eij Z*
      set flag = 1 if any vertex Zi was changed
  if flag on all procs still = 0, exit loop

Collate 4
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = (Eij,Zi), (Eik,Zi), (Eim,Zi), ... (all edges of Vi)
Reduce 4
  input: one KMV pair per vertex
  output: emit one KV pair for each edge in MV
  compute best Z* from all values in MV, best = min Z
  for each Eij in MV, emit 1 KV pair
    Key = Eij, Val = Z*

End of Loop (return to Collate 2)

Done:
  each zone is now a connected component
  each vertex is tagged with the zone Zi it is in

----------------------------------------------------------------------------
----------------------------------------------------------------------------

version of Cohen algorithm that does only CC, not distances
added 2-pass min finder to limit size of any component
  and load-balance it perfectly

P = # of procs running the problem
Nv = number of vertices in entire graph
Ne = number of edges in entire graph
Nz = number of zones = current number of connected components
Vi = vertex = unique ID = 1 int
Eij = edge = two vertex IDs = 2 ints
Zi = root vertex of Vi = zone ID = 1 int
Ri,Ci = random numbers from 0 to P-1 inclusive

Pre-processing:

Map 1
  input: read list of Ne edges
  output: emit 2 KV per edge
  Key = Vi, Val = Eij
  Key = Vj, Val = Eij
Collate 1
  input: 2*Ne KV pairs
  output: Nv KMV pairs
  Key = Vi, MVal = Eij Eik Eim ... (all edges of Vi)
Reduce 1
  input: one KMV pair per vertex Vi
  output: emit KV for each edge in MV, with initial zone Zi = Vi
  Key = Eij, Val = Zi

Loop:

Collate 2
  input: 2*Ne KV pairs, Vol = 6*Ne ints
  output: Ne KMV pairs
  Key = Eij, MVal = Zi Zj
Reduce 2
  input: one KMV pair per edge
  output: emit 1 or 2 KV pairs based on Zi,Zj values of vertices in edge
  if Zi = Zj: emit 1 KV pair
    Key = Zi Ri, Val = Eij Zi Ci (Ri,Ci generated randomly on each iteration;
                                  0 <= Ri, Ci < P)
  if Zi != Zj: emit 2 KV pairs (Zi = winner, Zj = loser)
    Key = Zi Ri, Val = Eij Zi Ci
    Key = Zj Ri, Val = Eij Zi Ci

Collate 3a
  input: one or two KV pairs per edge, 6*Ne ints <= Vol <= 12*Ne ints
  hash to processors based on Ri
  output: Nz*P KMV pairs
  Key = Zi Ri, MVal = (Eij Z C) (Eij Z C), ...
    (1/P fraction of all edges of all vertices in zone)
Reduce 3a
  input: one KMV pair per row of zone
  output: one KV pair for each edge in MV
  set flag = 0 for each proc
  loop over edges in MV:
    find winning edge Z* out of all Z values (min Z value)
  loop over edges in MV:
    emit Key = Zi Ci, Val = Eij Z* (no Ri, discard it)
    set flag = 1 if any edge's Zone was changed

Collate 3b
  input: one or two KV pair per edge, 5*Ne ints <= Vol <= 10*Ne ints
  hash to processors based on Ci
  output: Nz*P KMV pairs
  Key = Zi Ci, MVal = (Eij Z) (Eij Z) ...
    (1/P fraction of all edges of all vertices in zone)
Reduce 3b
  input: one KMV pair per column of zone
  output: emit two KV pairs for each edge in MV
  loop over edges in MV:
    find winning edge Z* out of all Z values (min Z value)
  loop over edges in MV:
    emit 2 KV per edge in MV:
      Key = Vi, Val = Eij Z*
      Key = Vj, Val = Eij Z*
      set flag = 1 if any edge's Zi was changed
  if flag on all procs still = 0, exit loop

Collate 4
  input: 2*Ne to 4*Ne KV pairs, 8*Ne ints <= Vol <= 16*Ne ints
  output: Nv KMV pairs
  Key = Vi, MVal = (Eij,Zi), (Eik,Zi), (Eim,Zi), ... (all edges of Vi)
                    May include duplicate edges with possibly different Z.
Reduce 4
  input: one KMV pair per vertex
  output: emit one KV pair for each edge in MV
  compute best Z* from all values in MV, best = min Z
  for each Eij in MV, emit 1 KV pair
    Key = Eij, Val = Z*

End of Loop (return to Collate 2)

Done:
  each zone is now a connected component
  each vertex is tagged with the zone Zi it is in
