SRC = 		mrvector.cpp mrmatrix.cpp test_matvec.cpp \
		test_pagerank.cpp \
                test_pagerank2.cpp \
		ccnd.cpp test_cc.cpp test_cc_common.cpp test_ccnd.cpp \
		random_mars.cpp \
		link2graph_weighted.cpp \
		mrglobalsum.cpp test_gs.cpp \
	        tri_new.cpp \
		sssp.cpp  \
		sssp_v2.cpp \
		wordfreq.cpp stress_test1.cpp stress_test2.cpp

OBJ = 		$(SRC:.cpp=.o)

# Targets

all:	matvec pagerank pagerank2 gs ccd ccnd link2graph_weighted wordfreq sssp sssp_v2 stress_test1 stress_test2 tri_new zerokv cc_driver rmat_driver tri_driver luby_driver

# Connected Components without distances; two versions of the 
# algorithm (original Cohen + more scalable Plimpton) can be run 
# with this executable.
ccnd:	test_ccnd.o test_cc_common.o ccnd.o random_mars.o $(LIB)
	$(LINK) $(LINKFLAGS) test_ccnd.o test_cc_common.o \
		ccnd.o random_mars.o \
		$(USRLIB) $(SYSLIB) -o ccnd

# Original Connect Components algorith by Cohen; includes distance
# calculation from root of each component.
ccd:	test_cc.o test_cc_common.o random_mars.o $(LIB)
	$(LINK) $(LINKFLAGS) test_cc.o test_cc_common.o random_mars.o \
		$(USRLIB) $(SYSLIB) -o ccd 

# Attempt to do global sums via MapReduce.
gs:	test_gs.o mrglobalsum.o $(LIB)
	$(LINK) $(LINKFLAGS) test_gs.o mrglobalsum.o \
		$(USRLIB) $(SYSLIB) -o gs

# MapReduce implementation of Google's pagerank.
pagerank:	test_pagerank.o mrmatrix.o mrvector.o $(LIB)
	$(LINK) $(LINKFLAGS) test_pagerank.o mrmatrix.o mrvector.o \
		$(USRLIB) $(SYSLIB) -o pagerank

# MapReduce implementation of Google's pagerank.
pagerank2:	test_pagerank2.o $(LIB)
	$(LINK) $(LINKFLAGS) test_pagerank2.o  \
		$(USRLIB) $(SYSLIB) -o pagerank2

# MapReduce implementation of matrix-vector multiplication.
matvec:	test_matvec.o mrmatrix.o mrvector.o $(LIB)
	$(LINK) $(LINKFLAGS) test_matvec.o mrmatrix.o mrvector.o \
		$(USRLIB) $(SYSLIB) -o matvec

# Program to convert data to MapReduce graph and/or MatrixMarket file.
link2graph_weighted:	link2graph_weighted.o $(LIB)
		$(LINK) $(LINKFLAGS) link2graph_weighted.o \
			$(USRLIB) $(SYSLIB) -o link2graph_weighted

# Program to compute single-source shortest paths.
sssp:		sssp.o $(LIB)
		$(LINK) $(LINKFLAGS) sssp.o \
			$(USRLIB) $(SYSLIB) -o sssp

# Program to compute single-source shortest paths.
sssp_v2:	sssp_v2.o $(LIB)
		$(LINK) $(LINKFLAGS) sssp_v2.o \
			$(USRLIB) $(SYSLIB) -o sssp_v2

# Program to count triangles in a graph.
tri:	tri.o $(LIB)
	$(LINK) $(LINKFLAGS) tri.o $(USRLIB) $(SYSLIB) -o tri

tri_new:	tri_new.o $(LIB)
	$(LINK) $(LINKFLAGS) tri_new.o $(USRLIB) $(SYSLIB) -o tri_new

# Program to compute wordcount of files.
wordfreq:	wordfreq.o $(LIB)
		$(LINK) $(LINKFLAGS) wordfreq.o \
			$(USRLIB) $(SYSLIB) -o wordfreq

# Program to compute wordcount of power-law numbers.
stress_test2:	stress_test2.o $(LIB)
		$(LINK) $(LINKFLAGS) stress_test2.o \
			$(USRLIB) $(SYSLIB) -o stress_test2


# Program to compute wordcount of files; simpler input.
stress_test1:	stress_test1.o $(LIB)
		$(LINK) $(LINKFLAGS) stress_test1.o \
			$(USRLIB) $(SYSLIB) -o stress_test1

# Program to compute wordcount of files; simpler input.
zerokv:	zerokv.o $(LIB)
	$(LINK) $(LINKFLAGS) zerokv.o $(USRLIB) $(SYSLIB) -o zerokv

# benchmark for RMAT generation

rmat_driver:	rmat_driver.o rmat_generate.o matrix_stats.o $(LIB)
	$(LINK) $(LINKFLAGS) rmat_driver.o rmat_generate.o matrix_stats.o \
	$(USRLIB) $(SYSLIB) -o rmat_driver

# benchmark for triangle finding

tri_driver:	tri_driver.o rmat_generate.o matrix_upper.o tri_find.o $(LIB)
	$(LINK) $(LINKFLAGS) tri_driver.o rmat_generate.o matrix_upper.o \
	tri_find.o $(USRLIB) $(SYSLIB) -o tri_driver

# benchmark for Luby's MIS algorithm

luby_driver:	luby_driver.o rmat_generate.o matrix_upper.o luby_find.o $(LIB)
	$(LINK) $(LINKFLAGS) luby_driver.o rmat_generate.o matrix_upper.o \
	luby_find.o $(USRLIB) $(SYSLIB) -o luby_driver

# benchmark for CC algorithm

cc_driver:	cc_driver.o rmat_generate.o cc_find.o cc_stats.o $(LIB)
	$(LINK) $(LINKFLAGS) cc_driver.o rmat_generate.o \
	cc_find.o cc_stats.o $(USRLIB) $(SYSLIB) -o cc_driver

# benchmark for SGI algorithm

sgi_driver:	sgi_driver.o read_mm_edge.o read_mm_vert.o \
		rmat_generate.o matrix_upper.o \
		vert_generate.o graph_label.o sgi_enumerate.o sgi_sample.o \
		$(LIB)
	$(LINK) $(LINKFLAGS) sgi_driver.o read_mm_edge.o read_mm_vert.o \
		rmat_generate.o \
		matrix_upper.o vert_generate.o graph_label.o \
		sgi_enumerate.o sgi_sample.o \
		$(USRLIB) $(SYSLIB) -o sgi_driver

sgi_check:	sgi_check.o $(LIB)
	$(LINK) $(LINKFLAGS) sgi_check.o \
		$(USRLIB) $(SYSLIB) -o sgi_check

# data2graph

data2graph:	data2graph.o $(LIB)
	$(LINK) $(LINKFLAGS) data2graph.o $(USRLIB) $(SYSLIB) -o data2graph

# data2rare

data2rare:	data2rare.o $(LIB)
	$(LINK) $(LINKFLAGS) data2rare.o $(USRLIB) $(SYSLIB) -o data2rare

# MP driver

mp_driver:	mp_driver.o $(LIB)
	$(LINK) $(LINKFLAGS) mp_driver.o $(USRLIB) $(SYSLIB) -o mp_driver

clean:
	rm *.o *.d
	rm matvec pagerank gs ccd ccnd tri_new link2graph_weighted sssp sssp_v2 stress_test1 stress_test2 wordfreq

# Rules

%.o:%.cpp
	$(CC) $(CCFLAGS) -c $<

%.o:%.c
	$(CC) $(CCFLAGS) -c $<

# Individual dependencies
%.d:%.cpp
	$(CC) $(CCFLAGS) $(DEPFLAGS) $< > $@

DEPENDS = $(OBJ:.o=.d)
include $(DEPENDS)

