This is the API to the PHISH library that minnows (stand-alone
applications) call.  This is a C-style API, so it is easy to write
minnows in any language, e.g. C, C++, Fortran, Python, that call
the PHISH library.

Decide where to doc the Python interface (in each doc page)?
Is the Sockets interface identical?

PHISH minnows send and receive datums by communicating with
other minnows.  Before looking at the specific library
calls for sending and receiving datums, its helpful to
understand how the data in a datum is structured by the
PHISH library.

This is discussed below, in the sub-section "What is a datum?"_#what.

The PHISH library is not large; there are only a handful of calls.
They can be grouped into the following 5 categories.  Follow the links
to see a doc page for each library call.  A general discussion of how
minnows call these functions is given in the "Minnows"_Minnows.html
section of the manual.

Library calls for initialization :olb,l
  void phish_init(int *pnarg, char ***pargs) :ulb,b
  int phish_init_python(int *narg, char **args) :b
  void phish_input(int iport, void (*datumfunc)(int), void (*donefunc)(), reqflag) :b
  void phish_output(int iport) :b
  void phish_done(void (*done)()) :b
  void phish_check() :ule,b

Library calls for shutdown :l
  void phish_exit() :ulb,b
  void phish_close(int iport) :ule,b

Library calls for receiving datums :l
  void phish_loop() :ulb,b
  void phish_probe(void (*probe)()) :b
  int phish_recv() :b
  int phish_unpack(char **buf, int *len) :b
  int phish_datum(char **buf, int *len) :ule,b

Library calls for sending datums :l
  void phish_send(int oport) :ulb,b
  void phish_send_key(int oport, char *key, int nbytes) :b
  void phish_send_direct(int oport, int receiver) :b
  void phish_pack_datum(char *buf, int n) :b
  void phish_pack_raw(char *buf, int n) :b
  void phish_pack_byte(char cvalue) :b
  void phish_pack_int(int ivalue) :b
  void phish_pack_uint64(uint64_t uvalue) :b
  void phish_pack_double(double dvalue) :b
  void phish_pack_string(char *str) :b
  void phish_pack_int_array(int *ivec, int n) :b
  void phish_pack_uint64_array(uint64_t *uvec, int n) :b
  void phish_pack_double_array(int *dvec, int n) :ule,b

Miscellaneous library calls :l
  int phish_world(int *pme, int *pnprocs) :ulb,b
  void phish_reset_receiver(int oport, int receiver) :b
  void phish_error(char *str) :b
  void phish_warn(char *str) :b
  double phish_timer() :ule,b
:ole

Discuss limits and options affecting library:

make MAXBUF and PHISH_SAFE_SEND be settable options by user?

:line
:line

What is a datum? :h4

A datum is a chunk of bytes sent from one PHISH minnow to another.
This section describes the format of the chunk, which is the same whether
the datum is sent via MPI or via sockets.

# of fields in datum (int)
type of 1st field (int)
size of 1st field (optional int)
data for 1st field (bytes)
type of 2nd field (int)
size of 2nd field (optional int)
data for 2nd field (bytes)
...
type of Nth field (int)
size of Nth field (optional int)
data for Nth field (bytes) :ul

The "type" values are one of these settings, as defined in src/phish.h:

#define PHISH_RAW 0
#define PHISH_BYTE 1
#define PHISH_INT 2
#define PHISH_UINT64 3
#define PHISH_DOUBLE 4
#define PHISH_STRING 5
#define PHISH_INT_ARRAY 6
#define PHISH_UINT64_ARRAY 7
#define PHISH_DOUBLE_ARRAY 8 :ul

PHISH_RAW is a list of raw bytes, which can be of any length, and
which the user can format in any manner.  PHISH_BYTE is a single byte.
PHISH_STRING is a NULL-terminated C-style string.  The NULL is
included in the datum.  The ARRAYS are contiguous lists of int, uint64
or double values.

The "size" values are only included for PHISH_RAW (# of bytes),
PHISH_STRING (# of bytes including NULL), and the ARRAY types (# of
values).

The field data is packed into the datum in a contiguous manner.

NOTE: what about alignment with mix of int/double, or when
single PHISH_BYTE are packed?

The maximum allowed size of a datum (in bytes) is set by MAXBUF in
src/phish.cpp, which defaults to 1 Mbyte.

Additionally, MPI flags the messages with a "tag".  This tag encodes
the receiver's port and also a "done" flag.  If it is not a done
message, the tag is the receiver's port (0 to Nport-1).  For a done
message a value of MAXPORT (defined at the top of src/phish.cpp) is
added to the tag.

How is this encoding of port and done implemented for sockets?

MPI also allows the receiver to query the byte size of the message,
which is used for the "full" pack/unpack calls below.

** C interface:



** Python interface:

def init(arguments=sys.argv):
  """Initializes phish and returns a context object for communicating with the
  rest of the school.  Takes the process argv (which may be modified) as its
  sole argument."""

class context:
  """Abstract interface for a Phish context, which is used for communication by
  individual minnows."""

  def name(self):
    """Returns the human-readable name for this minnow."""

  def input_ports(self):
    """Returns a list of connected input ports.  Note that this list is kept
    up-to-date as input ports are closed."""

  def output_ports(self):
    """Returns a list of connected output ports.  Note that this list is
    kept up-to-date as output ports are closed."""

  def enable_input_port(self, port, message_callback, closed_callback=None, optional=False):
    """Specifies an input port to be enabled, along with a callback to be
    called when a message is received on the port, an optional callback to be
    called when the port is closed (i.e. all connections to the port are
    closed), and a flag specifying whether the port is optional (i.e. whether
    it is an error condition if there are no connections to this port)."""

  def enable_output_port(self, port):
    """Specifies an output port to be enabled.  It is an error to attempt
    sending a message on a port that hasn't been enabled, or to make a
    connection to such a port."""

  def set_last_port_closed_callback(self, callback):
    """Specifies a callback to be called exactly once when every input port has
    been closed.  Note: this callback will never be called for minnows that
    have no input ports."""

  def loop(self):
    """Called to begin an event loop that will receive messages and invoke
    registered callbacks.  Loops cannot be nested, so subsequent calls to
    loop() before calling loop_complete() will be ignored."""

  def loop_complete(self):
    """Called to exit an event loop started with loop().  Note that multiple
    calls to loop_complete() and calls to loop_complete() before calling loop()
    will be ignored."""

  def send(self, message, output_port=0):
    """Sends a message to a single minnow connected to the given output
    port, choosing recipients in round-robin order."""

  def send_all(self, message, output_port=0):
    """Sends a message to every minnow connected to the given output
    port."""

  def send_hashed(self, key, value, output_port=0):
    """Sends a key-value pair to a single minnow connected to the given
    output port, choosing recipients based on a hash of the key."""

  def close_port(self, output_port):
    """Notifies downstream minnows that the given output port has been closed."""

  def close(self):
    """Closes the context and releases any resources allocated by the library.
    Note that this also implicitly closes any open output ports and completes
    any running loop."""

def school(backend="zmq"):
  """Factory function for creating school objects.  The backend argument is
  used to specify the backend to use for communications.  Currently, only "zmq"
  is supported as a backend."""

class school:
  """Abstract interface for managing a collection of minnow processes."""

  def create_minnows(self, name, arguments, count=1, hosts=None):
    """Starts one-or-more minnow processes, using the given command-line
    arguments, count of processes to create, and optional list of hosts where
    processes should be run, returning a list containing handles to the new
    minnows.  The hosts parameter must either be a single host, in which case
    all the new minnow processes will be run on that host (useful to put I/O
    minnows close to disk hardware, for example); or, the hosts parameter must
    be a list of host names, one-per-minnow."""

  def all_to_all(self, output_minnows, output_port, input_port, input_minnows):
    """Creates all-to-all connections from the output ports on one set of
    minnows to the input ports of another."""

  def one_to_one(self, output_minnows, output_port, input_port, input_minnows):
    """Connects an output port from one minnow to the input port of the
    corresponding minnow, for two equal sets of minnows."""

  def start(self):
    """Notifies the school that all minnows have been created / connected, and
    processing may begin."""

