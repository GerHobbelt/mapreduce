"MapReduce-MPI WWW Site"_mws - "MapReduce-MPI Documentation"_md :c

:link(mws,http://www.cs.sandia.gov/~sjplimp/mapreduce.html)
:link(md,Manual.html)

:line

MapReduce reduce() method :h3

int MapReduce::reduce(void (*myreduce)(char *, int, char *, int, int *, KeyValue *, void *), void *ptr) :pre

This calls the reduce() method of a MapReduce object, passing it a
function pointer to a reduce function you write.  It operates on a
KeyMultiValue object, calling your myreduce function once for each
unique key/multi-value pair owned by that processor.  A new KeyValue
object is created which stores all the key/value pairs generated by
your myreduce() function.  The method returns the total number of new
key/value pairs stored by all processors.

You can give this method a pointer (void *ptr) which will be returned
to your myreduce() function.  See the "Technical
Details"_technical.html section for why this can be useful.  Just
specify a NULL if you don't need this.

In this example the user function is called myreduce() and it must
have the following interface:

void myreduce(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr) :pre

A single key/multi-value pair is passed to your function from the
KeyMultiValue object stored by the MapReduce object.  The key is
typically unique to this reduce task and the multi-value is a list of
the nvalues associated with that key in the KeyMultiValue object.  The
char *multivalue argument is a pointer to the beginning of the
multi-value which contains all nvalues, packed one after the other.
The int *valuebytes argument is an array which stores the length of
each value in bytes.  If needed, it can be used by your function to
compute an offset into char *values for where each individual value
begins.  Your function is also passed a kv pointer to a new KeyValue
object created and stored internally by the MapReduce object.

Your myreduce() function can produce key/value pairs (though this is
not required) which it registers with the MapReduce object by calling
the "add()"_kv_add.html method of the KeyValue object.  The syntax for
registration is described on the doc page of the KeyValue
"add()"_kv_add.html method.  Alternatively, your myreduce() function
can write information to an output file.

See the "Technical Details"_technical.html section for details on the
byte-alignment of keys and values that are passed to your myreduce()
function and on how to byte-align keys and values you register with
the KeyValue "add()"_kv_add.html method.

This method is an on-processor operation, requiring no communication.
When run in parallel, each processor performs a myreduce() on each of
the key/value pairs it owns and stores any new key/value pairs it
generates.

:line

[Related methods]: "Keyvalue add()"_kv_add.html, "map()"_map.html
